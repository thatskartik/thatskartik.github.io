<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>cp</title>
<base href="https://thatskartik.github.io/" target="_self"/>
<link href="css/reset.css" rel="stylesheet"/>
<link href="css/tufte.css" rel="stylesheet"/>
<link href="css/latex.css" rel="stylesheet"/>
<link href="css/header_footer.css" rel="stylesheet"/>
<link href="css/table.css" rel="stylesheet"/>
<link href="css/tufte_pandoc_compat.css" rel="stylesheet"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full" type="text/javascript"></script>
</head>
<body>
<header>
<nav>
<a href="pub.html">Research</a>
<a href="posts.html">Posts</a>
<a href="index.html">Home</a>
</nav>
</header>
<article>
<section class="level3" id="neetcode-solutions-from-first-principles">
<h3>Neetcode solutions from First principles</h3>
<hr/>
</section>
<section class="level3" id="heaps">
<h3>Heaps</h3>
<p><u> <b>Problem 1 </b></u>: Find the <span class="math inline">\(k'th\)</span> largest element in a stream of numbers and allow them to “add” numbers as time progresses.</p>
<p>The data is an array. The unknown is the <span class="math inline">\(k'th\)</span> largest element. We can try a specialization of the problem where <span class="math inline">\(k = 1\)</span>. Such a problem only requires us to keep track of the maximum. For a general <span class="math inline">\(k\)</span> therefore, we only need to keep track of the top <span class="math inline">\(k\)</span>. Each time a smaller memebr appears than the worst (largest) of the top <span class="math inline">\(k\)</span> then we can update the list by inserting the necessary member in the right position and evicting the largest from the list.</p>
<p><u>Problem 2:</u> Keep smashing the heavier stones given a list of stones with their weights, the remaining part of a smash between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is <span class="math inline">\(y - x\)</span>. The larger remains and the smaller is destroyed.</p>
<p>The data is a list of stone weights and the procedure. The largest 2 are picked. Therefore, is it possible that only the largest 2 are of interest to us? No, I need to keep track of all the stones and their sizes, not only the top 2. Fine, then lets push everything into a heap first. Once that is done , we note a critical property in the operations <label class="margin-toggle sidenote-number" for="sidenote-1"></label><input class="margin-toggle" id="sidenote-1" type="checkbox"/><span class="sidenote">This property asks us to focus on how the data is taken from the Datastructure and how it is returned</span>. Once 2 elements are popped from the heap they aren’t of any significance anymore! Pick top 2 operate and then insert the residual.</p>
<p><u> Problem 3 </u> Find the <span class="math inline">\(k\)</span> closest points to origin given a list of arbitrary points.</p>
<p>Clearly the list is long, we need to keep track of only the <span class="math inline">\(k\)</span> closest points and nothing more. The heap must theorefore store only the distances of the points maybe mapped along with the point itself.</p>
<p><u> Problem 4</u> Retrieve the <span class="math inline">\(k'th\)</span> largest element from a list of elements without sorting the elements.</p>
<p>It is easy to just run insertion sort optimized with Binary search to solve the problem in <span class="math inline">\(O(k log n)\)</span> time complexity.</p>
<p><u> Problem 5 </u> Given a set of tasks and a cooldown time between identical tasks, figure out the fastest way a CPU can finish computation.</p>
<p>Clearly the problem does not care about the orientation of the array. Sorting the array can group the similar tasks. And a <em>set pass</em> over thae array can record the number of each type of task that is to be done. Another interesting approach is that the task can always be done with more cycles if we are given more than the minimum. This hints an attack using <em>binary search</em> . A third interesting approach is to use some sort of an ordered data structure. Such data structures tend to be quite useful in these sort of “sorting problems”. We could look at the problem from the persepective of a particular element, such as a CPU cycle. At each moment the CPU cycle can choose to pick a task, from a heap. Since all tasks are equivalent to the cycle. All of the elements are pushed into a priority queue first. After a task is done, a CPU cycle can only do this task at the time <span class="math inline">\(d + n\)</span> where <span class="math inline">\(d\)</span> was the time that particular task was popped from the queue.</p>
<p><u> Problem 6 </u> Print all subsets of a given set. We can generate all numbers between 0 and <span class="math inline">\(2^n\)</span> and then just choose the elements given by the binary member and append them to a list and then print them later.</p>
<p>Second approach is to draw a <em>recursion tree</em> and then note that we can perform a <em>depth first search</em> through the tree and then add them to a container. In order to code this one must keep in mind that the container must be passed by reference along with the partially made subset.</p>
<pre class="code">
class Solution {
public:
    vector<vector<int>&gt; subsets(vector<int>&amp; nums) {
        vector<vector<int>&gt;res;
        vector<int>subset;
        dfs(nums, 0, subset, res); //start the recursion
        return res;
    }


    void dfs(vector<int> &amp; nums, int index, vector<int>&amp; subset, vector<vector<int>&gt;&amp; res){
        if(index == nums.size()){
                res.push_back(subset);  //break the recursion and add the last state to the container
                return;
        }
        else{
            subset.push_back(nums[index]);
            dfs(nums, index + 1, subset, res); # make the branches and modify the state of the inntermediate variable
            subset.pop_back();
            dfs(nums, index + 1, subset, res);
        }
    }
};

</vector<int></int></int></int></vector<int></int></vector<int></pre>
<p>A general structure of a Tree traversal is like</p>
<pre class="code">Traverse(intermediate){
    if(intermediate is the end of the tree){
        add intermeidate to the container or just return if you don't want to
    }
    list possible new intermdiates
    for (all intermediates in list){
        traverse(new intermediate)
    }
}</pre>
<p><u> Problem 7 </u> Given an infinite amount of numbers present in the array, find the number of combinations that add to a particular value <code>target</code></p>
<p>Clearly the inteegers all need to be positive else there maybe an infinite length combination. To solve the problem we note that the intermediate variables are clearly again a subset. The target needs to be reached and we have a possible “re-usage” of an intermediate in the problem. This re-usage trick is the way to go when we have an “infinite amount” of some particular variable in the problem.</p>
<p>Intermediate variables should NOT be passed by reference, they must be passed by value, since the recursive calls can change these values. Only the container should be passed by reference.</p>
<p><a href="https://neetcode.io/problems/permutations">Problem 8</a>: The recursion for this problem is what I like to call a <em>linear</em> recursion which does not have branches unlike the previous problems. To compute the permutations we need only insert <span class="math inline">\(a_i\)</span> to permutations starting from <span class="math inline">\(i + 1\)</span> instead. The recursion proceeds linearly. However, be careful with the insertion function<label class="margin-toggle sidenote-number" for="sidenote-2"></label><input class="margin-toggle" id="sidenote-2" type="checkbox"/><span class="sidenote">The size of your array changes dynamically and therefore you migth run into an infinite loop</span></p>
<p>Problem 9: Find the number of <em>unique</em> subsets that add to a particular given number target.</p>
<p>The auxiliary problem is the non unique case. All that remains is to find a way to prevent making similar subsets again. We make similar subsets only when we first choose to ignore a particular <em>value</em> and then we choose it again in a later part fo the tree. To make this a bit easier to notice, we can use a sorted list and maintain an <em>unordered set</em> to keep track of which elements have been seen along the path. This is a <em>secondary intermediate</em> that can be kept track of while traversing the tree.</p>
<p>Problem 10: <em>Unique Subsets</em> that add to a particular number target. The subset we are building becomes a duplicate in the same way that the previous one does.</p>
</section>

</article>
<footer>
<hr/>
<div class="credits">
<span><a href="http://github.com/adityaramesh/tufte-blog">Tufte-Blog</a> uses
                    <a href="http://pandoc.org">Pandoc</a> along with
                    <a href="http://github.com/edwardtufte/tufte-css">Tufte CSS,</a>
<a href="http://mathjax.org">MathJax,</a> and
                    <a href="http://disqus.com">Disqus.</a>
</span></div>
</footer>
</body>
</html>